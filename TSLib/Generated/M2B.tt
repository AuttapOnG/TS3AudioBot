// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ include file="M2BParser.ttinclude" once="true" #>
<#@ include file="MessageParser.ttinclude" once="true" #>
<#@ include file="BookParser.ttinclude" once="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var genbook = BookDeclarations.Parse(Host.ResolvePath("../Declarations/Book.toml"));
var genmsg = Messages.Parse(Host.ResolvePath("../Declarations/Messages.toml"));
var genm2b = M2BDeclarations.Parse(Host.ResolvePath("../Declarations/MessagesToBook.toml"), genmsg, genbook);
#>
using TSLib.Messages;

<#= ConversionSet #>

namespace TSLib.Full.Book
{
	public partial class Connection
	{
#pragma warning disable IDE0017, CS0472, CS8073 // Ignore "Object initialization can be simplified", "Something with == and null..."
	<#
foreach (var rulegroup in genm2b.rule.GroupBy(rule => rule.from))
{
	ClearIndent();
	PushIndent("\t");
	var rulegroupList = rulegroup.ToArray();
	var msg = genmsg.NotifiesSorted.First(x => x.name == rulegroup.Key);
	WriteLine("public void Apply{0}({0} msg)", msg.name);
	WriteLine("{");
	PushIndent("\t");

	foreach (var rule in rulegroupList)
	{
		var bookTo = genbook.@struct.First(x => x.name == rule.to);
		var idStr = string.Join(", ", rule.id.Select(x => $"msg.{x}"));
		if (rulegroupList.Length > 1) { WriteLine("{"); PushIndent("\t"); }

		switch (rule.operation)
		{
		case "add":
		case "update":
			if (rule.operation == "add")
				WriteLine($"var obj = new {rule.to}();");
			else
				WriteLine($@"var obj = Get{rule.to}({idStr});
			if (obj == null) {{
				Log.Warn(""Internal Book protocol error. Update '{msg.name}' has no local object ({{$msg}})"", msg);
				return;
			}}");

			foreach (var prop in rule.properties.OrderBy(x => x.to))
			{
				void WriteMove(string from, string to)
				{
					var bookProp = bookTo.properties.FirstOrDefault(x => x.name == to);
					if (bookProp is null)
					{
						Warn($"No property found: '{to}'");
						return;
					}

					if (prop.operation is null)
					{
						switch (bookProp.mod)
						{
						case null:
							if (from == "null")
								WriteLine($"obj.{to} = null;");
							else
								WriteLine($"{{ var tmpv = {from}; if (tmpv != null) obj.{to} = ({bookProp.type})tmpv; }}");
							break;

						case "set":
							WriteLine($"{{ var tmpa = {from}; if (tmpa != null) {{ obj.{to}.Clear(); obj.{to}.UnionWith(tmpa); }} }}");
							break;

						case "array":
							WriteLine($"{{ var tmpa = {from}; if (tmpa != null) {{ obj.{to} = tmpa; }} }}");
							break;

						case "map":
							WriteLine($"// map update to {bookTo.name}.{bookProp.name}");
							break;

						default:
							throw new Exception("Unknown mod type: " + bookProp.mod);
						}
					}
					else if (prop.operation == "add")
					{
						// Currently hacky; Better check:
						//  [update:single->single]
						//  [add/remove/update:single->array]
						//  [update:array->array]
						WriteLine($"obj.{to}.Add({from});");
					}
					else if (prop.operation == "remove")
					{
						// Same here
						WriteLine($"obj.{to}.Remove({from});");
					}
					else
						throw new Exception("Unknown operation: " + prop.operation);
				}

				if (prop.from != null)
				{
					WriteMove($"msg.{prop.from}", prop.to);
				}
				else
				{ /* function */
					if (prop.function == "ReturnNone")
						WriteMove($"null", prop.tolist[0]);
					else if (prop.function == "VoidFun") { /* Do Nothing */ }
					else if (prop.tolist.Length == 0)
						WriteLine($"{prop.function}(msg);");
					else if (prop.tolist.Length == 1)
						WriteMove($"{prop.function}(msg)", prop.tolist[0]);
					else
					{
						WriteLine("{");
						WriteLine($"var tmp = {prop.function}(msg);", prop.to);
						for (int i = 0; i < prop.tolist.Length; i++)
							WriteMove($"tmp.Item{(i + 1)}", prop.tolist[i]);
						WriteLine("}");
					}
				}
			}
			if (rule.operation == "add")
			{
				WriteLine($"Set{rule.to}(obj{(string.IsNullOrEmpty(idStr) ? "" : (", " + idStr))});");
			}
			break;

		case "remove":
			WriteLine($"Remove{bookTo.name}({idStr});");
			break;
		}
		if (rulegroupList.Length > 1) { PopIndent(); WriteLine("}"); }
	}
	WriteLine($"Post{msg.name}(msg);");
	PopIndent();
	WriteLine("}");
	WriteLine("");

	WriteLine($"partial void Post{msg.name}({msg.name} msg);");
	WriteLine("");
}
#>
#pragma warning restore IDE0017, CS0472, CS8073
	}
}