// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />








#nullable enable
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace TSLib
{
	public static class TsTypes
	{
		public static IReadOnlyCollection<Type> All = new Type[] { typeof(Uid),typeof(ClientDbId),typeof(ClientId),typeof(ChannelId),typeof(ServerGroupId),typeof(ChannelGroupId), };
	}

	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(Uid.Converter))]
	public readonly partial struct Uid : IEquatable<Uid>
	{
		public static readonly Uid Null = new Uid(string.Empty);
		public static Uid To(String v) => new Uid(v);

		public String Value { get; }
		public Uid(String value) { if (value == null) throw new ArgumentNullException(nameof(value)); Value = value; }
		public static explicit operator Uid(String v) => new Uid(v);
		public static bool operator ==(Uid a, Uid b) => a.Value == b.Value;
		public static bool operator !=(Uid a, Uid b) => a.Value != b.Value;
		public override int GetHashCode() => Value?.GetHashCode() ?? 0 ;
		public override bool Equals(object? obj) => obj is Uid c && this.Equals(c);
		public override string ToString() => Value ?? "";
		
		public bool Equals(Uid other) => string.Equals(Value, other.Value, StringComparison.Ordinal);
		
		public static Uid? TryFrom(object value) {
			
			if (value is string s) return new Uid(s);
			return null;
			
		}

		internal class Converter : JsonConverter<Uid>
		{
			public override void Write(Utf8JsonWriter writer, Uid value, JsonSerializerOptions options)
				=> writer.WriteStringValue(value.Value);
			public override Uid Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)
				=> new(reader.GetString()?? throw new FormatException());
		}

		public class DictConverter<T> : JsonConverter<Dictionary<Uid, T>>
		{
			public override Dictionary<Uid, T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				throw new NotSupportedException();
			}

			public override void Write(Utf8JsonWriter writer, Dictionary<Uid, T> value, JsonSerializerOptions options)
			{
				writer.WriteStartObject();
				foreach (var kvp in value) {
					writer.WritePropertyName(kvp.Key.Value);
					JsonSerializer.Serialize(writer, kvp.Value, options);
				}
				writer.WriteEndObject();
			}
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ClientDbId.Converter))]
	public readonly partial struct ClientDbId : IFormattable, IEquatable<ClientDbId>
	{
		public static readonly ClientDbId Null = new ClientDbId(default);
		public static ClientDbId To(UInt64 v) => new ClientDbId(v);

		public UInt64 Value { get; }
		public ClientDbId(UInt64 value) {  Value = value; }
		public static explicit operator ClientDbId(UInt64 v) => new ClientDbId(v);
		public static bool operator ==(ClientDbId a, ClientDbId b) => a.Value == b.Value;
		public static bool operator !=(ClientDbId a, ClientDbId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ClientDbId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ClientDbId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ClientDbId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ClientDbId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ClientDbId(num);
			if (value is IConvertible c) return new ClientDbId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
		}

		internal class Converter : JsonConverter<ClientDbId>
		{
			public override void Write(Utf8JsonWriter writer, ClientDbId value, JsonSerializerOptions options)
				=> writer.WriteNumberValue(value.Value);
			public override ClientDbId Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)
				=> new(reader.GetUInt64());
		}

		public class DictConverter<T> : JsonConverter<Dictionary<ClientDbId, T>>
		{
			public override Dictionary<ClientDbId, T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				throw new NotSupportedException();
			}

			public override void Write(Utf8JsonWriter writer, Dictionary<ClientDbId, T> value, JsonSerializerOptions options)
			{
				writer.WriteStartObject();
				foreach (var kvp in value) {
					writer.WritePropertyName(kvp.Key.Value.ToString());
					JsonSerializer.Serialize(writer, kvp.Value, options);
				}
				writer.WriteEndObject();
			}
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ClientId.Converter))]
	public readonly partial struct ClientId : IFormattable, IEquatable<ClientId>
	{
		public static readonly ClientId Null = new ClientId(default);
		public static ClientId To(UInt16 v) => new ClientId(v);

		public UInt16 Value { get; }
		public ClientId(UInt16 value) {  Value = value; }
		public static explicit operator ClientId(UInt16 v) => new ClientId(v);
		public static bool operator ==(ClientId a, ClientId b) => a.Value == b.Value;
		public static bool operator !=(ClientId a, ClientId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ClientId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ClientId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ClientId? TryFrom(object value) {
			
			if (value is UInt16 bvalue) return new ClientId(bvalue);
			if (value is string s && UInt16.TryParse(s, out var num)) return new ClientId(num);
			if (value is IConvertible c) return new ClientId(c.ToUInt16(CultureInfo.InvariantCulture));

			return null;
			
		}

		internal class Converter : JsonConverter<ClientId>
		{
			public override void Write(Utf8JsonWriter writer, ClientId value, JsonSerializerOptions options)
				=> writer.WriteNumberValue(value.Value);
			public override ClientId Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)
				=> new(reader.GetUInt16());
		}

		public class DictConverter<T> : JsonConverter<Dictionary<ClientId, T>>
		{
			public override Dictionary<ClientId, T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				throw new NotSupportedException();
			}

			public override void Write(Utf8JsonWriter writer, Dictionary<ClientId, T> value, JsonSerializerOptions options)
			{
				writer.WriteStartObject();
				foreach (var kvp in value) {
					writer.WritePropertyName(kvp.Key.Value.ToString());
					JsonSerializer.Serialize(writer, kvp.Value, options);
				}
				writer.WriteEndObject();
			}
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ChannelId.Converter))]
	public readonly partial struct ChannelId : IFormattable, IEquatable<ChannelId>
	{
		public static readonly ChannelId Null = new ChannelId(default);
		public static ChannelId To(UInt64 v) => new ChannelId(v);

		public UInt64 Value { get; }
		public ChannelId(UInt64 value) {  Value = value; }
		public static explicit operator ChannelId(UInt64 v) => new ChannelId(v);
		public static bool operator ==(ChannelId a, ChannelId b) => a.Value == b.Value;
		public static bool operator !=(ChannelId a, ChannelId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ChannelId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ChannelId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ChannelId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ChannelId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ChannelId(num);
			if (value is IConvertible c) return new ChannelId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
		}

		internal class Converter : JsonConverter<ChannelId>
		{
			public override void Write(Utf8JsonWriter writer, ChannelId value, JsonSerializerOptions options)
				=> writer.WriteNumberValue(value.Value);
			public override ChannelId Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)
				=> new(reader.GetUInt64());
		}

		public class DictConverter<T> : JsonConverter<Dictionary<ChannelId, T>>
		{
			public override Dictionary<ChannelId, T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				throw new NotSupportedException();
			}

			public override void Write(Utf8JsonWriter writer, Dictionary<ChannelId, T> value, JsonSerializerOptions options)
			{
				writer.WriteStartObject();
				foreach (var kvp in value) {
					writer.WritePropertyName(kvp.Key.Value.ToString());
					JsonSerializer.Serialize(writer, kvp.Value, options);
				}
				writer.WriteEndObject();
			}
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ServerGroupId.Converter))]
	public readonly partial struct ServerGroupId : IFormattable, IEquatable<ServerGroupId>
	{
		public static readonly ServerGroupId Null = new ServerGroupId(default);
		public static ServerGroupId To(UInt64 v) => new ServerGroupId(v);

		public UInt64 Value { get; }
		public ServerGroupId(UInt64 value) {  Value = value; }
		public static explicit operator ServerGroupId(UInt64 v) => new ServerGroupId(v);
		public static bool operator ==(ServerGroupId a, ServerGroupId b) => a.Value == b.Value;
		public static bool operator !=(ServerGroupId a, ServerGroupId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ServerGroupId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ServerGroupId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ServerGroupId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ServerGroupId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ServerGroupId(num);
			if (value is IConvertible c) return new ServerGroupId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
		}

		internal class Converter : JsonConverter<ServerGroupId>
		{
			public override void Write(Utf8JsonWriter writer, ServerGroupId value, JsonSerializerOptions options)
				=> writer.WriteNumberValue(value.Value);
			public override ServerGroupId Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)
				=> new(reader.GetUInt64());
		}

		public class DictConverter<T> : JsonConverter<Dictionary<ServerGroupId, T>>
		{
			public override Dictionary<ServerGroupId, T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				throw new NotSupportedException();
			}

			public override void Write(Utf8JsonWriter writer, Dictionary<ServerGroupId, T> value, JsonSerializerOptions options)
			{
				writer.WriteStartObject();
				foreach (var kvp in value) {
					writer.WritePropertyName(kvp.Key.Value.ToString());
					JsonSerializer.Serialize(writer, kvp.Value, options);
				}
				writer.WriteEndObject();
			}
		}
	}
	
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(ChannelGroupId.Converter))]
	public readonly partial struct ChannelGroupId : IFormattable, IEquatable<ChannelGroupId>
	{
		public static readonly ChannelGroupId Null = new ChannelGroupId(default);
		public static ChannelGroupId To(UInt64 v) => new ChannelGroupId(v);

		public UInt64 Value { get; }
		public ChannelGroupId(UInt64 value) {  Value = value; }
		public static explicit operator ChannelGroupId(UInt64 v) => new ChannelGroupId(v);
		public static bool operator ==(ChannelGroupId a, ChannelGroupId b) => a.Value == b.Value;
		public static bool operator !=(ChannelGroupId a, ChannelGroupId b) => a.Value != b.Value;
		public override int GetHashCode() => Value.GetHashCode() ;
		public override bool Equals(object? obj) => obj is ChannelGroupId c && this.Equals(c);
		public override string ToString() => Value .ToString();
		
		public bool Equals(ChannelGroupId other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		
		public static ChannelGroupId? TryFrom(object value) {
			
			if (value is UInt64 bvalue) return new ChannelGroupId(bvalue);
			if (value is string s && UInt64.TryParse(s, out var num)) return new ChannelGroupId(num);
			if (value is IConvertible c) return new ChannelGroupId(c.ToUInt64(CultureInfo.InvariantCulture));

			return null;
			
		}

		internal class Converter : JsonConverter<ChannelGroupId>
		{
			public override void Write(Utf8JsonWriter writer, ChannelGroupId value, JsonSerializerOptions options)
				=> writer.WriteNumberValue(value.Value);
			public override ChannelGroupId Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)
				=> new(reader.GetUInt64());
		}

		public class DictConverter<T> : JsonConverter<Dictionary<ChannelGroupId, T>>
		{
			public override Dictionary<ChannelGroupId, T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				throw new NotSupportedException();
			}

			public override void Write(Utf8JsonWriter writer, Dictionary<ChannelGroupId, T> value, JsonSerializerOptions options)
			{
				writer.WriteStartObject();
				foreach (var kvp in value) {
					writer.WritePropertyName(kvp.Key.Value.ToString());
					JsonSerializer.Serialize(writer, kvp.Value, options);
				}
				writer.WriteEndObject();
			}
		}
	}
	
}