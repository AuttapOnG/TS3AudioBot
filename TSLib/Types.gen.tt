// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var types = new (string alias, string backing, bool isStr)[] {
	("Uid", "String", true),
	("ClientDbId", "UInt64", false),
	("ClientId", "UInt16", false),
	("ChannelId", "UInt64", false),
	("ServerGroupId", "UInt64", false),
	("ChannelGroupId", "UInt64", false),
	//("IconId", "Int32", false),
	//("ConnectionId", "UInt32", false),
};
#>
#nullable enable
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace TSLib
{
	public static class TsTypes
	{
		public static IReadOnlyCollection<Type> All = new Type[] { <# foreach(var (alias,_,_) in types) { Write($"typeof({alias}),"); } #> };
	}

	<# foreach(var (alias, backing, isStr) in types) { #>
	[StructLayout(LayoutKind.Sequential, Pack=0)]
	[DebuggerDisplay("{Value, nq}")]
	[JsonConverter(typeof(<#= alias #>.Converter))]
	public readonly partial struct <#= alias #> :<#= isStr ? "" : " IFormattable," #> IEquatable<<#= alias #>>
	{
		public static readonly <#= alias #> Null = new <#= alias #>(<#= isStr ? "string.Empty" : "default" #>);
		public static <#= alias #> To(<#= backing #> v) => new <#= alias #>(v);

		public <#= backing #> Value { get; }
		public <#= alias #>(<#= backing #> value) { <#= isStr ? "if (value == null) throw new ArgumentNullException(nameof(value));" : "" #> Value = value; }
		public static explicit operator <#= alias #>(<#= backing #> v) => new <#= alias #>(v);
		public static bool operator ==(<#= alias #> a, <#= alias #> b) => a.Value == b.Value;
		public static bool operator !=(<#= alias #> a, <#= alias #> b) => a.Value != b.Value;
		public override int GetHashCode() => <#= isStr ? "Value?.GetHashCode() ?? 0" : "Value.GetHashCode()" #> ;
		public override bool Equals(object? obj) => obj is <#= alias #> c && this.Equals(c);
		public override string ToString() => Value <#= isStr ? "?? \"\"" : ".ToString()" #>;
		<# if (isStr) { #>
		public bool Equals(<#= alias #> other) => string.Equals(Value, other.Value, StringComparison.Ordinal);
		<# } else { #>
		public bool Equals(<#= alias #> other) => Value.Equals(other.Value);
		public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);
		<# } #>
		public static <#= alias #>? TryFrom(object value) {
			<# if (isStr) { #>
			if (value is string s) return new <#= alias #>(s);
			return null;
			<# } else { #>
			if (value is <#= backing #> bvalue) return new <#= alias #>(bvalue);
			if (value is string s && <#= backing #>.TryParse(s, out var num)) return new <#= alias #>(num);
			if (value is IConvertible c) return new <#= alias #>(c.To<#= backing #>(CultureInfo.InvariantCulture));

			return null;
			<# } #>
		}

		internal class Converter : JsonConverter<<#= alias #>>
		{
			public override void Write(Utf8JsonWriter writer, <#= alias #> value, JsonSerializerOptions options)
				=> writer.<#= isStr ? "WriteStringValue" : "WriteNumberValue" #>(value.Value);
			public override <#= alias #> Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)
				=> new(reader.Get<#= backing #>()<#= isStr ? "?? throw new FormatException()" : "" #>);
		}

		public class DictConverter<T> : JsonConverter<Dictionary<<#= alias #>, T>>
		{
			public override Dictionary<<#= alias #>, T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
			{
				throw new NotSupportedException();
			}

			public override void Write(Utf8JsonWriter writer, Dictionary<<#= alias #>, T> value, JsonSerializerOptions options)
			{
				writer.WriteStartObject();
				foreach (var kvp in value) {
					writer.WritePropertyName(kvp.Key.Value<#= isStr ? "" : ".ToString()" #>);
					JsonSerializer.Serialize(writer, kvp.Value, options);
				}
				writer.WriteEndObject();
			}
		}
	}
	<# } #>
}